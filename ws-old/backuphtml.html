<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Word Search Game</title>
		<link rel="stylesheet" href="styles/main.css" />
	</head>
	<body>
		<div id="topBar">
			<button id="settingsButton">☰</button>
			<div id="topBarProgress">
				<div class="progress-bar">
					<div class="progress-fill"></div>
				</div>
				<div id="statsText">0/0 words found</div>
			</div>
			<div id="timer">00:00</div>
		</div>

		<div id="settingsContainer">
			<button id="closeSettingsButton">×</button>
			<h2>Settings</h2>
			<div id="wins">Wins: 0</div>
			<button id="newGameButton">New Game</button>
			<button id="hintButton">💡</button>
			<button id="soundButton">🔊</button>
			<div class="setting">
				<label for="difficulty">Difficulty:</label>
				<select id="difficulty">
					<option value="easy">Easy</option>
					<option value="medium" selected>Medium</option>
					<option value="hard">Hard</option>
				</select>
			</div>
			<div class="setting">
				<label for="category">Category:</label>
				<select id="category">
					<option value="animals" selected>Animals</option>
					<option value="disney">Disney</option>
					<option value="famousLandmarks">Famous Landmarks</option>
					<option value="friendsAndFamilies">Friends & Family</option>
					<option value="fruits">Fruits</option>
					<option value="greekGods">Greek Gods</option>
					<option value="harryPotter">Harry Potter</option>
					<option value="space">Space</option>
					<option value="superheroes">Superheroes</option>
					<option value="vampireDiaries">Vampire Diaries</option>
					<option value="vegetables">Vegetables</option>
				</select>
			</div>
		</div>

		<div id="settingsOverlay"></div>

		<div id="game">
			<div id="wordSearchContainer"></div>
			<div id="wordsContainer"></div>
			<div id="dotsContainer"></div>
		</div>

			<div class="dots" id="dotsContainer"></div>

			<div class="flex-center">
				<div id="wordSearchContainer">
					<svg id="lineSVG">
						<line
							id="selectionLine"
							x1="0"
							y1="0"
							x2="0"
							y2="0"
							stroke="#d500ff"
							stroke-width="20"
							stroke-opacity="0"
							stroke-linecap="round"
						/>
					</svg>
				</div>
			</div>
		</div>

		<script>
			const categories = {
				animals: [
					"ELEPHANT",
					"TIGER",
					"LION",
					"MONKEY",
					"GORILLA",
					"GIRAFFE",
					"HIPPOPOTAMUS",
					"CROCODILE",
					"ALLIGATOR",
					"RABBIT",
					"FOX",
					"WOLF",
					"BEAR",
					"PANDA",
					"KOALA",
					"KANGAROO",
					"ZEBRA",
					"LEOPARD",
					"CHEETAH",
					"HYENA",
					"OSTRICH",
					"PEACOCK",
					"PARROT",
					"EAGLE",
					"OWL",
					"HAWK",
					"FALCON",
					"PENGUIN",
					"SEAL",
					"WALRUS",
					"DOLPHIN",
					"WHALE",
					"SHARK",
					"TURTLE",
					"TROUT",
					"SALMON",
					"GOLDFISH",
					"CATFISH",
					"BASS",
					"FLAMINGO",
					"SWAN",
					"DUCK",
					"GOOSE",
					"TURKEY",
					"CHICKEN",
					"ROOSTER",
					"HEN",
					"COW",
					"PIG",
				],
				disney: [
					"MICKEY",
					"MINNIE",
					"DONALD",
					"DAISY",
					"GOOFY",
					"PLUTO",
					"CHIP",
					"DALE",
					"CINDERELLA",
					"SNOWWHITE",
					"AURORA",
					"ARIEL",
					"BELLE",
					"JASMINE",
					"POCAHONTAS",
					"MULAN",
					"TIANA",
					"RAPUNZEL",
					"MERIDA",
					"ELSA",
					"ANNA",
					"MOANA",
					"ALADDIN",
					"GENIE",
					"JAFAR",
					"ABU",
					"RAJAH",
					"IAGO",
					"FLYNN",
					"MAXIMUS",
					"PASCAL",
					"ERIC",
					"SEBASTIAN",
					"FLOUNDER",
					"URSULA",
					"MUFASA",
					"SIMBA",
					"NALA",
					"SCAR",
					"TIMON",
					"PUMBAA",
					"RAFIKI",
					"ZAZU",
					"PETERPAN",
					"TINKERBELL",
					"HOOK",
					"SMEE",
					"WENDY",
					"JOHN",
					"MICHAEL",
					"TIGERLILY",
					"ALICE",
					"CHESHIRE",
					"MADHATTER",
					"QUEENOFHEARTS",
					"DUMBO",
					"TIMOTHY",
					"JIMINY",
					"PINOCCHIO",
					"GEPPETTO",
					"CLEO",
					"FIGARO",
					"STITCH",
					"LILO",
					"JUMBA",
					"PLEAKLEY",
					"COBRA",
					"GASTON",
					"LEFOU",
					"MAURICE",
					"BAYMAX",
					"HIRO",
					"TADASHI",
					"HONEY",
					"FRED",
					"WASABI",
					"GO",
					"DISNEYLAND",
					"DISNEYWORLD",
					"MAGIC",
					"KINGDOM",
					"EPCOT",
					"ANIMAL",
					"HOLLYWOOD",
					"STUDIOS",
					"PIXAR",
					"TOYSTORY",
					"BUZZ",
					"WOODY",
					"JESSIE",
					"HAMM",
					"SLINKY",
					"REX",
					"BOPEEP",
					"FORKY",
					"ANDY",
					"SID",
					"WALLE",
					"EVE",
					"MO",
					"COCO",
					"MIGUEL",
					"HECTOR",
					"ERNESTO",
					"DORY",
					"NEMO",
					"MARLIN",
					"GILL",
					"BRUCE",
					"SQUIRT",
					"CRUSH",
					"BAMBI",
					"THUMPER",
					"FLOWER",
					"BAMBI",
					"LADY",
					"TRAMP",
					"SCAMP",
					"JOCK",
					"TRUSTY",
					"PEG",
					"TONY",
					"SCROOGE",
					"HUEY",
					"DEWEY",
					"LOUIE",
					"WEBBY",
					"FLINTHEART",
					"DUCKTALES",
					"BALOO",
					"BAGHEERA",
					"SHEREKHAN",
					"KAA",
					"MOWGLI",
					"KINGLOUIE",
					"WINNIE",
					"PIGLET",
					"TIGGER",
					"EEYORE",
					"ROO",
					"KANGA",
					"OWL",
					"RABBIT",
					"CHRISTOPHERROBIN",
					"RALPH",
					"VANELLOPE",
					"FELIX",
					"CALHOUN",
					"KINGCANDY",
					"SARGENTCALHOUN",
					"GOGO",
					"ELASTIGIRL",
					"MRINCREDIBLE",
					"DASH",
					"VIOLET",
					"FROZONE",
					"SYNDROME",
					"EDNA",
					"JACKJACK",
					"REMIE",
					"LINGUINI",
					"COLETTE",
					"SKINNER",
					"DJANGO",
					"EMILE",
					"GUSTEAU",
					"RALPH",
					"MABEL",
					"GRAVITYFALLS",
					"DIPPER",
					"SOOS",
					"STAN",
					"WENDY",
					"PACIFICA",
					"MARCELINE",
					"FIONNA",
					"BMO",
					"JAKE",
					"FINN",
					"LEMONGRAB",
					"PRINCESSBUBBLEGUM",
					"LUMPYSPACEPRINCESS",
					"ICEKING",
					"MARSHALLLEE",
					"HUNSON",
					"MOOSE",
					"SPIDER",
					"HATCHIMALS",
					"GROGU",
					"MANDO",
					"CARADUNE",
					"MIGS",
					"KUIIL",
					"IG11",
					"MOFFGIDEON",
					"BOBAFETT",
					"DINJARIN",
					"MANDALORIAN",
					"CHEWBACCA",
					"HAN",
					"LEIA",
					"LUKE",
					"YODA",
					"R2D2",
					"C3PO",
					"DARTHVADER",
					"PALPATINE",
					"KYLOREN",
					"REY",
					"FINN",
					"POE",
					"BB8",
					"ROSE",
					"JYN",
					"CASSIAN",
					"KRENNIC",
					"GALEN",
					"SAW",
					"MONMOTHMA",
					"DROIDS",
					"JAWA",
					"TUSKEN",
					"LANDO",
					"EWOKS",
					"HERA",
					"KANAN",
					"EZRA",
					"SABINE",
					"ZEB",
					"CHOPPER",
					"AHSOKA",
					"ADVENTURELAND",
					"FANTASYLAND",
					"FRONTIERLAND",
					"TOMORROWLAND",
					"MAINSTREET",
					"CRITTERCOUNTRY",
					"NEWORLEANS",
					"NEWORLEANSSQUARE",
					"LIBERTYSQUARE",
					"DISNEYSPRINGS",
					"MICKEYMOUSE",
					"MINNIEMOUSE",
					"DISNEYCHARACTER",
					"MAGICCARPET",
					"PIXIEHOLLOW",
					"CASTLE",
					"CINDERELLACASTLE",
					"SLEEPINGBEAUTYCASTLE",
					"SPACE",
					"SPACEMOUNTAIN",
					"BIGTHUNDER",
					"BIGTHUNDERMOUNTAIN",
					"SPLASHMOUNTAIN",
					"MATTERHORN",
					"INDIANAJONES",
					"PIRATESOFTHECARIBBEAN",
					"JUNGLECRUISE",
					"HAUNTEDMANSION",
					"ITSA",
					"SMALLWORLD",
					"TEACUPS",
					"MADTEAPARTY",
					"DUMBO",
					"DISNEYPARK",
					"DISNEYWORLD",
					"MAGICKINGDOM",
					"ANIMALKINGDOM",
					"EPCOT",
					"HOLLYWOODSTUDIOS",
					"DISNEYLANDPARIS",
					"DISNEYTOKYO",
					"DISNEYLANDSHANGHAI",
					"DISNEYLANDHONGKONG",
					"DISNEYCALIFORNIAADVENTURE",
					"MAINSTREETUSA",
					"ADVENTURELAND",
					"NEWORLEANSQUARE",
					"CRITTERCOUNTRY",
					"FRONTIERLAND",
					"FANTASYLAND",
					"TOMORROWLAND",
					"LIBERTYSQUARE",
					"MICKEYS",
					"TOONTOWN",
					"STARWARS",
					"GALAXYSEDGE",
					"JUNGLECRUISE",
					"ENCHANTEDTIKIROOM",
					"PIRATES",
					"PIRATESOFTHECARIBBEAN",
					"HAUNTED",
					"MANSION",
					"SPLASH",
					"BIGTHUNDER",
					"THUNDER",
					"MOUNTAIN",
					"RAILROAD",
					"FANTASY",
					"FANTASYFAIRE",
					"CAROUSELOFPROGRESS",
					"COUNTRYBEAR",
					"JAMBOREE",
					"MATTERHORNBOBSLEDS",
					"AUTOPIA",
					"TOMORROWLAND",
					"SPEEDWAY",
					"MONSTERSINC",
					"JIMINYCRICKET",
					"SNOWWHITE",
					"SEVENDWARFS",
					"FAIRYTALE",
					"FAIRYTALEHALL",
					"DREAMS",
					"DISNEYPRINCESS",
					"RAPUNZEL",
					"TANGLED",
					"FROZEN",
					"FROZENFEVER",
					"MOANA",
					"LIONKING",
					"SIMBA",
					"CIRCLEOFLIFE",
					"HERCULES",
					"HERCULEAN",
					"ZEUS",
					"PEGASUS",
					"MEGARA",
					"PHIL",
					"HADES",
					"GOOFY",
					"GOOFYTROOP",
					"PLUTO",
					"DONALDDUCK",
					"DUCKTALES",
					"DARKWINGDUCK",
					"CHIPDALE",
					"REMY",
					"RATATOUILLE",
					"LIGHTNING",
					"MCQUEEN",
					"CARS",
					"MATER",
					"TOYSTORY",
					"BUZZLIGHTYEAR",
					"WOODY",
					"ANDY",
					"REX",
					"HAMM",
					"MRPOTATOHEAD",
					"ALIEN",
					"SPACERANGER",
					"SLINKYDOG",
					"RC",
					"LOTO",
					"BOPEEP",
					"DUKECABOOM",
					"TOINFINITYANDBEYOND",
					"PIXAR",
					"UP",
					"CARL",
					"ELLIE",
					"RUSSELL",
					"KEVIN",
					"DOUG",
					"WALL",
					"BOLT",
					"BAYMAX",
					"HIRO",
					"BIGHERO6",
					"FROZEN",
					"ELSA",
					"ANNA",
					"KRISTOFF",
					"OLAF",
					"HANS",
					"SVEN",
					"TARZAN",
					"JANE",
					"CLAYTON",
					"KALA",
					"KERCHAK",
					"TREASUREPLANET",
					"JIM",
					"MORPH",
					"LONGJOHN",
					"SILVER",
					"ATLANTIS",
					"KIDA",
					"MILO",
					"REINDEER",
					"MOANALOA",
					"HEIHEI",
					"PUGA",
					"VOYAGER",
					"WAYFINDER",
					"FIREFLY",
					"RAY",
					"NAVEEN",
					"TIANA",
					"LOUIS",
					"DRFACILIER",
					"CHARLOTTE",
					"LABOUFF",
					"MAMAODIE",
					"RAY",
					"EVANGELINE",
					"DISNEYANIMATION",
					"PIXARANIMATION",
					"DISNEYPIXAR",
					"DREAMWORKS",
					"BLUE",
					"SKYSTUDIOS",
					"ILLUMINATION",
					"ENTERTAINMENT",
					"DISNEYCHANNEL",
					"DISNEYJUNIOR",
					"DISNEYXD",
					"DISNEYMOVIES",
					"WALT",
					"DISNEYPICTURES",
					"DISNEYCARTOONS",
					"DISNEYPLUS",
					"DISNEYONICE",
					"DISNEYCRUISELINE",
				],
				famousLandmarks: [
					"EIFFEILTOWER",
					"STATUEOFLIBERTY",
					"GREATWALL",
					"PYRAMIDS",
					"TAJMAHAL",
					"BIGBEN",
					"COLISEUM",
					"MACHUPICCHU",
					"CHRISTTHEREDEEMER",
					"SYDNEYOPERA",
					"LEANINGTOWER",
					"SAHARA",
					"LOUVRE",
					"STONEHENGE",
					"NIAGARAFALLS",
					"MTFUJI",
					"TIMESQUARE",
					"BURJKHALIFA",
					"GRANDCANYON",
					"YELLOWSTONE",
					"LIBERTYBELL",
					"HOLLYWOODSIGN",
					"GOLDENGATE",
					"MOUNTROUSHMORE",
					"ALCATRAZ",
					"ANGKORWAT",
					"BIGSUR",
					"CAPETOWN",
					"CASTELOBRANCO",
					"CATHEDRALOFSEVILLA",
					"CATHEDRALOFTOLEDO",
					"CATSDACUNHA",
					"CHURCHOFTHESAVIOR",
					"CNTOWER",
					"DENALI",
					"DUOMOFLORENCE",
					"FUSHIMIINARI",
					"GOLDENTEMPLE",
					"GREATBARRIER",
					"GREATBUDDHA",
					"KREMLIN",
					"LINCOLNMEMORIAL",
					"MOUNTKILIMANJARO",
					"NEUSCHWANSTEIN",
					"PATAGONIA",
					"SAHARA",
					"SERENGETI",
					"SPHINX",
					"STONEHENGE",
				],
				friendsAndFamilies: [
					"JAMES",
					"CAITLIN",
					"HARRINGTON",
					"ROBBINS",
					"JOHATHAN",
					"JONAH",
					"OWEN",
					"NATALIE",
					"HEATHER",
					"KEVIN",
					"NANA",
					"GIGI",
					"KAYTI",
					"BOB",
					"MELISSA",
					"SIA",
					"KK",
					"YAMS",
					"KITTY",
					"KEKE",
					"HEATHER",
					"BETH",
					"ELIZABETH",
					"HERNDON",
					"FATHER",
					"MOTHER",
					"BROTHER",
					"SISTER",
					"UNCLE",
					"AUNT",
					"COUSIN",
					"GRANDFATHER",
					"GRANDMOTHER",
				],
				fruits: [
					"APPLE",
					"APRICOT",
					"AVOCADO",
					"BANANA",
					"BLACKBERRY",
					"BLUEBERRY",
					"CANTALOUPE",
					"CHERRY",
					"CLEMENTINE",
					"COCONUT",
					"CRANBERRY",
					"DATE",
					"DRAGONFRUIT",
					"DURIAN",
					"ELDERBERRY",
					"FIG",
					"GOOSEBERRY",
					"GRAPE",
					"GRAPEFRUIT",
					"GUAVA",
					"HONEYDEW",
					"JACKFRUIT",
					"KIWI",
					"KUMQUAT",
					"LEMON",
					"LIME",
					"LYCHEE",
					"MANGO",
					"MELON",
					"NECTARINE",
					"ORANGE",
					"PAPAYA",
					"PASSIONFRUIT",
					"PEACH",
					"PEAR",
					"PERSIMMON",
					"PINEAPPLE",
					"PLUM",
					"POMEGRANATE",
					"QUINCE",
					"RASPBERRY",
					"STRAWBERRY",
					"TANGERINE",
					"WATERMELON",
					"APRICOT",
					"BLACKCURRANT",
					"BREADFRUIT",
					"CARAMBOLA",
					"CUSTARDAPPLE",
					"SALAK",
				],
				greekGods: [
					"ZEUS",
					"HERA",
					"POSEIDON",
					"DEMETER",
					"ATHENA",
					"APOLLO",
					"ARTEMIS",
					"ARES",
					"APHRODITE",
					"HEPHAESTUS",
					"HERMES",
					"HESTIA",
					"DIONYSUS",
					"HADES",
					"PERSEPHONE",
					"HERACLES",
					"HECATE",
					"HELIOS",
					"SELENE",
					"EOS",
					"GAIA",
					"URANUS",
					"KRONOS",
					"RHEA",
					"PROMETHEUS",
					"EPIMETHEUS",
					"ATLAS",
					"OCEANUS",
					"TETHYS",
					"NYX",
					"NEMESIS",
					"ERIS",
					"HYPNOS",
					"THANATOS",
					"MORPHEUS",
					"NIKE",
					"TYCHE",
					"JANUS",
					"PAN",
					"EOS",
					"LETO",
					"THEMIS",
					"THETIS",
					"METIS",
					"HEMERA",
					"PHAETHON",
					"ASCLEPIUS",
					"AMPHITRITE",
					"EILEITHYIA",
					"ADONIS",
				],
				harryPotter: [
					"HARRY",
					"RON",
					"HERMIONE",
					"DUMBLEDORE",
					"SNAPE",
					"VOLDEMORT",
					"HAGRID",
					"MCGONAGALL",
					"SIRIUS",
					"LUPIN",
					"DRACO",
					"NEVILLE",
					"LUNA",
					"GINNY",
					"FRED",
					"GEORGE",
					"DOBBY",
					"KREACHER",
					"FUDGE",
					"UMBRIDGE",
					"MALFOY",
					"BELLATRIX",
					"PETER",
					"CHO",
					"CEDRIC",
					"VICTOR",
					"KARKAROFF",
					"FLEUR",
					"MOLLY",
					"ARTHUR",
					"PERCY",
					"BILL",
					"CHARLIE",
					"TONKS",
					"KINGSLEY",
					"MOODY",
					"LOCKHART",
					"QUIRRELL",
					"SPRAGUE",
					"FILCH",
					"FLITWICK",
					"TRELAWNEY",
					"POMONA",
					"ARGUS",
					"PENNY",
					"ANGELINA",
					"LEE",
					"DEAN",
					"SEAMUS",
				],
				space: [
					"ASTEROID",
					"ASTRONAUT",
					"BLACKHOLE",
					"COMET",
					"COSMOS",
					"CRATER",
					"EARTH",
					"ECLIPSE",
					"GALAXY",
					"GRAVITY",
					"JUPITER",
					"LIGHTYEAR",
					"MARS",
					"METEOR",
					"MOON",
					"NEBULA",
					"NEPTUNE",
					"ORBIT",
					"PLANET",
					"PLUTO",
					"QUASAR",
					"ROCKET",
					"SATELLITE",
					"SATURN",
					"SOLARSYSTEM",
					"SPACE",
					"SPACESHIP",
					"SPACESTATION",
					"STAR",
					"STARDUST",
					"SUPERNOVA",
					"TELESCOPE",
					"UNIVERSE",
					"URANUS",
					"VENUS",
					"CONSTELLATION",
					"GALACTIC",
					"INTERSTELLAR",
					"MILKYWAY",
					"PULSAR",
					"REDGIANT",
					"SOLARFLARE",
					"SPACEDEBRIS",
					"SPACETIME",
					"SPACEWALK",
					"STARCLUSTER",
					"STARGAZING",
					"SUPERMASSIVE",
					"WHITEHOLE",
				],
				superheroes: [
					"SUPERMAN",
					"BATMAN",
					"WONDERWOMAN",
					"SPIDERMAN",
					"IRONMAN",
					"THOR",
					"HULK",
					"CAPTAINAMERICA",
					"FLASH",
					"GREENLANTERN",
					"AQUAMAN",
					"CYBORG",
					"BLACKWIDOW",
					"HAWKEYE",
					"DOCTORSTRANGE",
					"BLACKPANTHER",
					"SCARLETWITCH",
					"VISION",
					"ANTMAN",
					"WASP",
					"STARLORD",
					"GROOT",
					"ROCKET",
					"GAMORA",
					"DRAX",
					"LOKI",
					"NICKFURY",
					"SHURI",
					"WOLVERINE",
					"DEADPOOL",
					"PROFESSORX",
					"MAGNETO",
					"BEAST",
					"MYSTIQUE",
					"ROGUE",
					"STORM",
					"CYCLOPS",
					"JEANGREY",
					"ICEMAN",
					"NIGHTCRAWLER",
					"COLOSSUS",
					"JOKER",
					"HARLEYQUINN",
					"LEXLUTHOR",
					"DOOMSDAY",
					"BRAINIAC",
					"REDCAPTAIN",
					"BANE",
					"DEATHSTROKE",
				],
				vampireDiaries: [
					"DAMON",
					"STEFAN",
					"ELENA",
					"CAROLINE",
					"BONNIE",
					"JEREMY",
					"ALARIC",
					"TYLER",
					"KLAUS",
					"ELIJAH",
					"REBEKAH",
					"KATHERINE",
					"MATT",
					"JENNA",
					"ENZO",
					"SILAS",
					"JO",
					"LIV",
					"LUKE",
					"LIZ",
					"JOHN",
					"GRAMS",
					"MASON",
					"LILY",
					"ISOBEL",
					"GRAYSON",
					"MIRANDA",
					"ANNA",
					"VICKI",
					"JULES",
					"ROSE",
					"LEXI",
					"APRIL",
					"AARON",
					"NADIA",
					"MARKOS",
					"TRIPP",
				],
				vegetables: [
					"ARTICHOKE",
					"ARUGULA",
					"ASPARAGUS",
					"BEANSPROUT",
					"BEETROOT",
					"BELLPEPPER",
					"BROCCOLI",
					"BRUSSELSSPROUTS",
					"CABBAGE",
					"CARROT",
					"CAULIFLOWER",
					"CELERY",
					"CHARD",
					"CHICORY",
					"COLLARDGREENS",
					"CORN",
					"CUCUMBER",
					"DAIKON",
					"EGGPLANT",
					"ENDIVE",
					"FENNEL",
					"GARLIC",
					"GINGER",
					"GREENBEAN",
					"HORSERADISH",
					"JICAMA",
					"KALE",
					"KOHLRABI",
					"LEEKS",
					"LETTUCE",
					"MUSHROOM",
					"OKRA",
					"ONION",
					"PARSNIP",
					"PEAS",
					"POTATO",
					"PUMPKIN",
					"RADICCHIO",
					"RADISH",
					"RUTABAGA",
					"SCALLION",
					"SHALLOT",
					"SPINACH",
					"SQUASH",
					"SWEETPOTATO",
					"TARO",
					"TOMATO",
					"TURNIP",
					"WATERCRESS",
					"ZUCCHINI",
				],
			};

			class WordSearch {
				constructor() {
					this.gridSize = 8;
					this.wordsCount = 6;
					this.grid = [];
					this.words = [];
					this.selectedCategory = "programming";
					this.placedWords = [];
					this.foundWords = new Set();
					this.selectedCells = [];
					this.isSelecting = false;
					this.currentSelection = { start: null, end: null };
					this.pages = [];
					this.currentPage = 0;
					this.foundWordsCount = 0;
					this.placedWordsCount = 0;
					this.drawnLines = [];
					this.time = 0;
					this.timerInterval = null;
					this.timerPaused = false;
					this.timerStopped = false;
					this.resizeHandler = () => this.adjustGridSize();
					this.menuToggling = false;
					this.audioContext = null;
					this.soundEnabled = true;
					this.initAudio();
					// Affirmations
					this.affirmations = [
						"You are beautiful!",
						"Skillful Execution!",
						"Genius!",
						"Unstoppable!",
						"Legendary!",
						"You did it!",
						"Brilliant!",
						"You rock!",
						"Superb!",
						"Outstanding!",
						"Incredible!",
						"Phenomenal!",
						"You crushed it!",
						"Victory!",
						"Spectacular!",
						"You're a star!",
						"Flawless Victory!",
						"Magnificent!",
						"You're amazing!",
						"Word Wizard!",
						"Champion!",
						"Perfection!",
						"Marvelous!",
						"You're unstoppable!",
						"So smart!",
						"You nailed it!",
					];
					this.init();
				}

				init() {
					this.loadSettings();
					this.updateWinsCount();
					this.setupMenu();
					this.setupEventListeners();
					this.createWordSearch();
					this.startTimer();
				}

				cleanup() {
					// Clear timer
					this.stopTimer();

					// Remove event listeners
					window.removeEventListener("resize", this.resizeHandler);

					// Clear any stored line data
					this.drawnLines = [];

					// Close audio context
					if (this.audioContext) {
						this.audioContext.close();
					}
				}

				// Audio system
				initAudio() {
					try {
						this.audioContext = new (window.AudioContext ||
							window.webkitAudioContext)();
					} catch (e) {
						console.warn("Web Audio API not supported");
						this.soundEnabled = false;
					}
				}

				playSound(frequency, duration = 0.2, type = "sine", volume = 0.1) {
					if (!this.soundEnabled || !this.audioContext) return;

					const oscillator = this.audioContext.createOscillator();
					const gainNode = this.audioContext.createGain();

					oscillator.connect(gainNode);
					gainNode.connect(this.audioContext.destination);

					oscillator.frequency.setValueAtTime(
						frequency,
						this.audioContext.currentTime
					);
					oscillator.type = type;

					gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
					gainNode.gain.linearRampToValueAtTime(
						volume,
						this.audioContext.currentTime + 0.01
					);
					gainNode.gain.exponentialRampToValueAtTime(
						0.001,
						this.audioContext.currentTime + duration
					);

					oscillator.start(this.audioContext.currentTime);
					oscillator.stop(this.audioContext.currentTime + duration);
				}

				playWordFoundSound() {
					// Happy ascending chord
					this.playSound(523.25, 0.15, "sine", 0.08); // C5
					setTimeout(() => this.playSound(659.25, 0.15, "sine", 0.08), 50); // E5
					setTimeout(() => this.playSound(783.99, 0.2, "sine", 0.08), 100); // G5
				}

				playHintSound() {
					// Mysterious sound
					this.playSound(440, 0.3, "triangle", 0.06);
					setTimeout(() => this.playSound(554.37, 0.3, "triangle", 0.06), 150);
				}

				playGameCompleteSound() {
					// Victory fanfare
					const notes = [523.25, 659.25, 783.99, 1046.5]; // C5, E5, G5, C6
					notes.forEach((note, i) => {
						setTimeout(() => this.playSound(note, 0.4, "sine", 0.1), i * 100);
					});
				}

				playClickSound() {
					// if (!this.soundEnabled || !this.audioContext) return;
					// // Subtle pop: short sine with quick pitch drop
					// const osc = this.audioContext.createOscillator();
					// const gain = this.audioContext.createGain();
					// osc.type = "sine";
					// osc.frequency.setValueAtTime(380, this.audioContext.currentTime);
					// osc.frequency.linearRampToValueAtTime(
					// 	220,
					// 	this.audioContext.currentTime + 0.08
					// );
					// gain.gain.setValueAtTime(0.12, this.audioContext.currentTime);
					// gain.gain.linearRampToValueAtTime(
					// 	0.001,
					// 	this.audioContext.currentTime + 0.09
					// );
					// osc.connect(gain);
					// gain.connect(this.audioContext.destination);
					// osc.start(this.audioContext.currentTime);
					// osc.stop(this.audioContext.currentTime + 0.09);
				}

				// Animation system
				createParticles(x, y, count = 8, color = "#9200b7") {
					for (let i = 0; i < count; i++) {
						const particle = document.createElement("div");
						particle.className = "particle";
						particle.style.left = x + "px";
						particle.style.top = y + "px";
						particle.style.background = color;

						const angle = (i / count) * Math.PI * 2;
						const velocity = 50 + Math.random() * 50;
						const vx = Math.cos(angle) * velocity;
						const vy = Math.sin(angle) * velocity;

						document.body.appendChild(particle);

						let posX = x;
						let posY = y;
						let opacity = 1;

						const animate = () => {
							posX += vx * 0.02;
							posY += vy * 0.02 + 0.5; // gravity
							opacity -= 0.02;

							particle.style.left = posX + "px";
							particle.style.top = posY + "px";
							particle.style.opacity = opacity;

							if (opacity > 0) {
								requestAnimationFrame(animate);
							} else {
								document.body.removeChild(particle);
							}
						};

						requestAnimationFrame(animate);
					}
				}

				createFloatingText(text, x, y, color = "#9200b7") {
					const floatingText = document.createElement("div");
					floatingText.className = "floating-text";
					floatingText.textContent = text;
					floatingText.style.left = x + "px";
					floatingText.style.top = y + "px";
					floatingText.style.color = color;

					document.body.appendChild(floatingText);

					setTimeout(() => {
						if (document.body.contains(floatingText)) {
							document.body.removeChild(floatingText);
						}
					}, 1000);
				}

				createSparkles(x, y, count = 5) {
					for (let i = 0; i < count; i++) {
						setTimeout(() => {
							const sparkle = document.createElement("div");
							sparkle.className = "sparkle";
							sparkle.style.left = x + (Math.random() - 0.5) * 100 + "px";
							sparkle.style.top = y + (Math.random() - 0.5) * 100 + "px";

							document.body.appendChild(sparkle);

							setTimeout(() => {
								if (document.body.contains(sparkle)) {
									document.body.removeChild(sparkle);
								}
							}, 1000);
						}, i * 100);
					}
				}

				shakeScreen() {
					document.getElementById("game").classList.add("game-shake");
					setTimeout(() => {
						document.getElementById("game").classList.remove("game-shake");
					}, 500);
				}

				pulseTimer() {
					document.getElementById("timer").classList.add("timer-pulse");
					setTimeout(() => {
						document.getElementById("timer").classList.remove("timer-pulse");
					}, 300);
				}

				celebrateProgress() {
					const progressBar = document.getElementById("progressFill");
					progressBar.classList.add("progress-celebration");
					setTimeout(() => {
						progressBar.classList.remove("progress-celebration");
					}, 1000);
				}

				loadSettings() {
					try {
						const settings = JSON.parse(
							localStorage.getItem("wordSearchSettings") || "{}"
						);
						if (settings.difficulty) {
							document.getElementById("difficultySelect").value =
								settings.difficulty;
							this.setDifficulty(settings.difficulty);
						}
						if (settings.category) {
							document.getElementById("categorySelect").value =
								settings.category;
							this.setCategory(settings.category);
						}
					} catch (error) {
						console.warn("Failed to load settings from localStorage:", error);
					}
				}

				saveSettings() {
					try {
						const settings = {
							difficulty: document.getElementById("difficultySelect").value,
							category: document.getElementById("categorySelect").value,
						};
						localStorage.setItem(
							"wordSearchSettings",
							JSON.stringify(settings)
						);
					} catch (error) {
						console.warn("Failed to save settings to localStorage:", error);
					}
				}

				setupMenu() {
					const settingsButton = document.getElementById("settingsButton");
					const settingsContainer = document.getElementById("settingsContainer");
					const closeSettingsButton = document.getElementById("closeSettingsButton");
					const settingsOverlay = document.getElementById("settingsOverlay");

					settingsButton.addEventListener("click", () => {
						if (this.menuToggling) return;
						this.menuToggling = true;

							settingsContainer.classList.add("open");
							settingsOverlay.classList.add("open");

							setTimeout(() => (this.menuToggling = false), 300);
					});

					const closeMenu = () => {
						settingsContainer.classList.remove("open");
						settingsOverlay.classList.remove("open");
					};

					closeSettingsButton.addEventListener("click", closeMenu);
					settingsOverlay.addEventListener("click", closeMenu);

					document.addEventListener("click", (event) => {
						if (
							!settingsContainer.contains(event.target) &&
							!settingsButton.contains(event.target) &&
							settingsContainer.classList.contains("open")
						) {
							closeMenu();
						}
					});
				}

				setDifficulty(level) {
					const settings = {
						easy: [8, 6],
						medium: [10, 8],
						hard: [14, 12],
						veryhard: [20, 16],
						insane: [30, 25],
					};
					[this.gridSize, this.wordsCount] = settings[level] || [8, 6];
					this.saveSettings();
				}

				setCategory(category) {
					this.selectedCategory = category;
					this.words = categories[category] || categories.programming;
					this.saveSettings();
				}

				getRandomWords(num) {
					// Filter words that can fit in the grid
					const validWords = this.words.filter(
						(word) => word.length <= this.gridSize
					);
					const shuffled = [...validWords].sort(() => 0.5 - Math.random());
					return shuffled.slice(0, Math.min(num, shuffled.length));
				}

				createWordSearch() {
					// Close menu and overlay
					document.getElementById("settingsContainer").classList.remove("open");
					document.getElementById("settingsOverlay").classList.remove("open");

					this.createGrid();
					this.placeWords();
					this.fillEmptyCells();
					this.renderGrid();
					this.renderWordsList();
					this.paginateWords();
					this.adjustGridSize();
					this.updateStats();
					this.resetTimer();
					this.clearOldLines();

					// Reset pagination to first page
					this.currentPage = 0;
				}

				createGrid() {
					this.grid = Array(this.gridSize)
						.fill()
						.map(() => Array(this.gridSize).fill(""));
					this.placedWords = [];
					this.foundWords = new Set();
					this.foundWordsCount = 0;
					this.placedWordsCount = 0;
					this.drawnLines = []; // Clear stored line data
				}

				placeWords() {
					const words = this.getRandomWords(this.wordsCount);
					const directions = [
						{ dx: 1, dy: 0 }, // horizontal
						{ dx: 0, dy: 1 }, // vertical
						{ dx: 1, dy: 1 }, // diagonal down-right
						{ dx: 1, dy: -1 }, // diagonal up-right
						{ dx: -1, dy: 0 }, // horizontal left
						{ dx: 0, dy: -1 }, // vertical up
						{ dx: -1, dy: -1 }, // diagonal up-left
						{ dx: -1, dy: 1 }, // diagonal down-left
					];

					for (const word of words) {
						let placed = false;
						let attempts = 0;

						while (!placed && attempts < 100) {
							const direction =
								directions[Math.floor(Math.random() * directions.length)];

							// Fix off-by-1 error: ensure word fits within grid bounds
							const maxX =
								direction.dx === 0
									? this.gridSize - 1
									: direction.dx > 0
									? this.gridSize - word.length
									: word.length - 1;
							const maxY =
								direction.dy === 0
									? this.gridSize - 1
									: direction.dy > 0
									? this.gridSize - word.length
									: word.length - 1;

							const startX = Math.floor(Math.random() * (maxX + 1));
							const startY = Math.floor(Math.random() * (maxY + 1));

							if (this.canPlaceWord(word, startX, startY, direction)) {
								this.placeWord(word, startX, startY, direction);
								placed = true;
								this.placedWordsCount++;
							}
							attempts++;
						}
					}
				}

				canPlaceWord(word, startX, startY, direction) {
					for (let i = 0; i < word.length; i++) {
						const x = startX + direction.dx * i;
						const y = startY + direction.dy * i;

						if (x < 0 || x >= this.gridSize || y < 0 || y >= this.gridSize) {
							return false;
						}

						if (this.grid[y][x] !== "" && this.grid[y][x] !== word[i]) {
							return false;
						}
					}
					return true;
				}

				placeWord(word, startX, startY, direction) {
					const positions = [];

					for (let i = 0; i < word.length; i++) {
						const x = startX + direction.dx * i;
						const y = startY + direction.dy * i;
						this.grid[y][x] = word[i];
						positions.push({ x, y });
					}

					this.placedWords.push({
						word: word,
						positions: positions,
					});
				}

				fillEmptyCells() {
					const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

					for (let y = 0; y < this.gridSize; y++) {
						for (let x = 0; x < this.gridSize; x++) {
							if (this.grid[y][x] === "") {
								this.grid[y][x] =
									letters[Math.floor(Math.random() * letters.length)];
							}
						}
					}
				}

				renderGrid() {
					const gridElement = document.getElementById("wordSearchContainer");
					// Clear only the cells, keep the SVG
					const svg = gridElement.querySelector("#lineSVG");
					gridElement.innerHTML = "";
					if (svg) {
						gridElement.appendChild(svg);
					}

					const cells = [];
					for (let y = 0; y < this.gridSize; y++) {
						for (let x = 0; x < this.gridSize; x++) {
							const cell = document.createElement("div");
							cell.className = "cell";
							cell.textContent = this.grid[y][x];
							cell.dataset.x = x;
							cell.dataset.y = y;
							cell.style.opacity = "0";
							gridElement.appendChild(cell);
							cells.push({ cell, x, y });
						}
					}

					// Animate cells dropping in with chaotic delays
					this.animateCellDrop(cells);
				}

				animateCellDrop(cells) {
					// Shuffle cells for random drop order
					const shuffled = [...cells].sort(() => Math.random() - 0.5);

					shuffled.forEach((item, index) => {
						setTimeout(() => {
							item.cell.style.opacity = "1";
							item.cell.classList.add("cell-drop");

							// Play a subtle sound for some cells
							if (index % 4 === 0 && this.soundEnabled) {
								const freq = 200 + (item.x + item.y) * 50;
								this.playSound(freq, 0.05, "sine", 0.02);
							}

							// Remove animation class after completion
							setTimeout(() => {
								item.cell.classList.remove("cell-drop");
							}, 800);
						}, index * 15 + Math.random() * 30); // Staggered with some randomness
					});
				}

				renderWordsList() {
					const container = document.getElementById("wordsContainer");

					// Clear all existing content (pages and dots)
					container.innerHTML = "";
					document.getElementById("dotsContainer").innerHTML = "";

					// Create first page
					const firstPage = document.createElement("div");
					firstPage.className = "page";
					container.appendChild(firstPage);

					this.placedWords.forEach(({ word }) => {
						const wordElement = document.createElement("div");
						wordElement.className = "word";
						wordElement.textContent = word;
						wordElement.dataset.word = word;
						firstPage.appendChild(wordElement);
					});
				}

				paginateWords() {
					const container = document.getElementById("wordsContainer");
					const dotsContainer = document.getElementById("dotsContainer");

					// Get all word elements that were just created
					const words = Array.from(document.querySelectorAll(".word"));
					const wordsPerPage = 8; // Increased for better use of space

					this.pages = [];
					container.innerHTML = "";
					dotsContainer.innerHTML = "";

					// Only paginate if we have words
					if (words.length === 0) return;

					for (let i = 0; i < words.length; i += wordsPerPage) {
						const page = document.createElement("div");
						page.className = "page";
						words
							.slice(i, i + wordsPerPage)
							.forEach((word) => page.appendChild(word));
						this.pages.push(page);
						container.appendChild(page);
					}

					// Only create dots if we have multiple pages
					if (this.pages.length > 1) {
						this.pages.forEach((page, index) => {
							const dot = document.createElement("div");
							dot.className = "dot";
							if (index === 0) dot.classList.add("active");
							dot.addEventListener("click", () => this.showPage(index));
							dotsContainer.appendChild(dot);
						});
					}

					this.showPage(0);
				}

				showPage(pageIndex) {
					this.currentPage = pageIndex;
					this.pages.forEach((page, index) => {
						page.style.display = index === pageIndex ? "flex" : "none";
					});

					document.querySelectorAll(".dot").forEach((dot, index) => {
						dot.classList.toggle("active", index === pageIndex);
					});
				}

				adjustGridSize() {
					const container = document.getElementById("wordSearchContainer");
					const gameArea = document.getElementById("game");
					const wordsContainer = document.getElementById("wordsContainer");
					const dotsContainer = document.getElementById("dotsContainer");

					// Calculate available space
					const topBarHeight = document.getElementById("topBar").offsetHeight;
					const wordsHeight = wordsContainer.offsetHeight;
					const dotsHeight = dotsContainer.offsetHeight;
					const padding = 40; // Total padding

					const availableHeight =
						window.innerHeight -
						topBarHeight -
						wordsHeight -
						dotsHeight -
						padding;
					const availableWidth = window.innerWidth - 40;

					// Calculate maximum cell size
					const maxCellSize =
						Math.min(
							Math.floor(availableWidth / this.gridSize),
							Math.floor(availableHeight / this.gridSize),
							60 // Maximum cell size
						) - 2; // Account for grid gap

					const fontSize = Math.max(12, Math.min(24, maxCellSize * 0.6));

					container.style.gridTemplateColumns = `repeat(${this.gridSize}, ${maxCellSize}px)`;

					document.querySelectorAll(".cell").forEach((cell) => {
						cell.style.width = `${maxCellSize}px`;
						cell.style.height = `${maxCellSize}px`;
						cell.style.fontSize = `${fontSize}px`;
					});

					// Update SVG size
					const svg = document.getElementById("lineSVG");
					const rect = container.getBoundingClientRect();
					svg.style.width = `${rect.width}px`;
					svg.style.height = `${rect.height}px`;

					// Calculate dynamic line width based on cell size
					const lineWidth = Math.max(3, Math.min(20, maxCellSize * 0.3));

					// Update selection line width
					const selectionLine = document.getElementById("selectionLine");
					selectionLine.setAttribute("stroke-width", lineWidth);

					// Update all permanent lines
					const allLines = svg.querySelectorAll("line:not(#selectionLine)");
					allLines.forEach((line) => {
						line.setAttribute("stroke-width", lineWidth);
					});

					// Redraw permanent lines with new positions
					this.redrawLines();
				}

				redrawLines() {
					// Clear all permanent lines except the selection line
					const svg = document.getElementById("lineSVG");
					while (svg.children.length > 1) {
						svg.removeChild(svg.lastChild);
					}

					// Redraw permanent lines for found words
					this.drawnLines.forEach((lineData) => {
						this.drawPermanentLineFromData(lineData);
					});
				}

				setupEventListeners() {
					// Remove existing event listeners to prevent accumulation
					window.removeEventListener("resize", this.resizeHandler);
					window.addEventListener("resize", this.resizeHandler);

					const grid = document.getElementById("wordSearchContainer");

					grid.addEventListener("mousedown", (e) => {
						if (e.target.classList.contains("cell")) {
							this.startSelection(e.target, e);
						}
					});

					grid.addEventListener("mousemove", (e) => {
						if (this.isSelecting && e.target.classList.contains("cell")) {
							this.updateSelection(e.target, e);
						}
					});

					grid.addEventListener("mouseup", () => {
						this.endSelection();
					});

					// Touch events - only prevent default when actually selecting
					grid.addEventListener("touchstart", (e) => {
						const touch = e.touches[0];
						const element = document.elementFromPoint(
							touch.clientX,
							touch.clientY
						);
						if (element && element.classList.contains("cell")) {
							e.preventDefault(); // Only prevent default for cell touches
							this.startSelection(element, touch);
						}
					});

					grid.addEventListener("touchmove", (e) => {
						if (this.isSelecting) {
							e.preventDefault();
							const touch = e.touches[0];
							const element = document.elementFromPoint(
								touch.clientX,
								touch.clientY
							);
							if (element && element.classList.contains("cell")) {
								this.updateSelection(element, touch);
							}
						}
					});

					grid.addEventListener("touchend", (e) => {
						if (this.isSelecting) {
							e.preventDefault();
							this.endSelection();
						}
					});
				}

				startSelection(cell, event) {
					this.isSelecting = true;
					this.currentSelection.start = {
						x: parseInt(cell.dataset.x),
						y: parseInt(cell.dataset.y),
						element: cell,
					};
					this.clearSelection();
					this.clearHints(); // Clear any active hints
					this.selectCell(cell);

					// Make line visible
					const line = document.getElementById("selectionLine");
					line.setAttribute("stroke-opacity", "0.8");

					// Play click sound
					this.playClickSound();
				}

				updateSelection(cell, event) {
					// Snap selection to the nearest valid direction
					const start = this.currentSelection.start;
					const x = parseInt(cell.dataset.x);
					const y = parseInt(cell.dataset.y);
					const dx = x - start.x;
					const dy = y - start.y;

					// Determine which direction is closest
					let snapX = start.x;
					let snapY = start.y;
					if (Math.abs(dx) >= Math.abs(dy) && Math.abs(dx) >= Math.abs(dy)) {
						// Horizontal
						snapX = x;
						snapY = start.y;
					}
					if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) >= Math.abs(dx)) {
						// Vertical
						snapX = start.x;
						snapY = y;
					}
					if (Math.abs(dx) === Math.abs(dy) && dx !== 0) {
						// Diagonal
						snapX = x;
						snapY = y;
					}

					this.currentSelection.end = {
						x: snapX,
						y: snapY,
						element: document.querySelector(
							`[data-x="${snapX}"][data-y="${snapY}"]`
						),
					};
					this.updateSelectionDisplay();
				}

				endSelection() {
					if (this.isSelecting) {
						this.checkForWord();
						this.clearSelection();
						this.clearLine();
						this.isSelecting = false;
						this.currentSelection = { start: null, end: null };
					}
				}

				updateSelectionDisplay() {
					this.clearSelection();

					if (!this.currentSelection.start || !this.currentSelection.end)
						return;

					const cells = this.getSelectionCells();
					cells.forEach((pos) => {
						const cell = document.querySelector(
							`[data-x="${pos.x}"][data-y="${pos.y}"]`
						);
						if (cell) this.selectCell(cell);
					});

					this.updateLine(
						this.currentSelection.start,
						this.currentSelection.end
					);
				}

				getSelectionCells() {
					if (!this.currentSelection.start || !this.currentSelection.end)
						return [];

					const { start, end } = this.currentSelection;
					const dx = end.x - start.x;
					const dy = end.y - start.y;

					// Only allow horizontal, vertical, or perfect diagonal
					if (
						(dx === 0 && dy !== 0) ||
						(dy === 0 && dx !== 0) ||
						(Math.abs(dx) === Math.abs(dy) && dx !== 0)
					) {
						const length = Math.max(Math.abs(dx), Math.abs(dy));
						const stepX = dx === 0 ? 0 : dx / Math.abs(dx);
						const stepY = dy === 0 ? 0 : dy / Math.abs(dy);
						const cells = [];
						for (let i = 0; i <= length; i++) {
							cells.push({
								x: start.x + stepX * i,
								y: start.y + stepY * i,
							});
						}
						return cells;
					}
					// If not a valid straight line, only select the start cell
					return [start];
				}

				selectCell(cell) {
					cell.style.backgroundColor = "rgba(146, 0, 183, 0.5)";
					cell.classList.add("selected");
					this.selectedCells.push(cell);
				}

				clearSelection() {
					this.selectedCells.forEach((cell) => {
						cell.style.backgroundColor = "";
						cell.classList.remove("selected");
					});
					this.selectedCells = [];
				}

				clearHints() {
					document.querySelectorAll(".cell.hint").forEach((cell) => {
						cell.classList.remove("hint");
					});
				}

				checkForWord() {
					const cells = this.getSelectionCells();
					if (cells.length < 2) return;

					let selectedWord = "";
					cells.forEach((pos) => {
						selectedWord += this.grid[pos.y][pos.x];
					});

					const reverseWord = selectedWord.split("").reverse().join("");

					const foundWord = this.placedWords.find(
						(pw) => pw.word === selectedWord || pw.word === reverseWord
					);

					if (foundWord && !this.foundWords.has(foundWord.word)) {
						this.foundWords.add(foundWord.word);
						this.foundWordsCount++;

						// Play word found sound
						this.playWordFoundSound();

						this.markWordAsFound(foundWord.word, cells);
						this.updateWordsList();
						this.updateStats();
						this.drawPermanentLine(
							this.currentSelection.start,
							this.currentSelection.end
						);

						// Celebrate progress
						this.celebrateProgress();

						if (this.foundWordsCount === this.placedWordsCount) {
							this.gameComplete();
						}
					}
				}

				markWordAsFound(word, cells) {
					cells.forEach((pos, index) => {
						const cell = document.querySelector(
							`[data-x="${pos.x}"][data-y="${pos.y}"]`
						);
						if (cell) {
							cell.style.backgroundColor = "rgba(146, 0, 183, 0.8)";
							cell.style.color = "#fff";

							// Add bounce animation with delay
							setTimeout(() => {
								cell.classList.add("found-animation");
								setTimeout(() => {
									cell.classList.remove("found-animation");
								}, 600);
							}, index * 50);
						}
					});

					// Create particles at the center of the word
					if (cells.length > 0) {
						const centerIndex = Math.floor(cells.length / 2);
						const centerCell = document.querySelector(
							`[data-x="${cells[centerIndex].x}"][data-y="${cells[centerIndex].y}"]`
						);
						if (centerCell) {
							const rect = centerCell.getBoundingClientRect();
							const x = rect.left + rect.width / 2;
							const y = rect.top + rect.height / 2;
							this.createParticles(x, y, 12, "#d500ff");
							this.createFloatingText(word, x - 50, y - 30, "#9200b7");
							this.createSparkles(x, y, 8);
						}
					}
				}

				updateWordsList() {
					this.foundWords.forEach((word) => {
						const wordElement = document.querySelector(`[data-word="${word}"]`);
						if (wordElement) {
							wordElement.classList.add("found");
						}
					});
				}

				updateStats() {
					const progress = (this.foundWordsCount / this.placedWordsCount) * 100;
					// document.getElementById("progressFill").style.width = `${progress}%`;
					document.getElementById(
						"statsText"
					).textContent = `${this.foundWordsCount} of ${this.placedWordsCount} words found`;
				}

				gameComplete() {
					this.stopTimer();
					this.incrementWins();

					// Play victory sound
					this.playGameCompleteSound();

					// Epic confetti effect
					if (typeof confetti !== "undefined") {
						// Multiple confetti bursts
						confetti({
							particleCount: 100,
							spread: 70,
							origin: { y: 0.6 },
						});

						setTimeout(() => {
							confetti({
								particleCount: 50,
								spread: 60,
								origin: { x: 0.25, y: 0.6 },
							});
						}, 200);

						setTimeout(() => {
							confetti({
								particleCount: 50,
								spread: 60,
								origin: { x: 0.75, y: 0.6 },
							});
						}, 400);

						// Rainbow mode for celebration
						document.getElementById("game").classList.add("rainbow-mode");
						setTimeout(() => {
							document.getElementById("game").classList.remove("rainbow-mode");
						}, 3000);
					}

					// Screen shake for impact
					this.shakeScreen();

					// Create victory particles
					const centerX = window.innerWidth / 2;
					const centerY = window.innerHeight / 2;
					// Pick a random affirmation
					const affirmation =
						this.affirmations[
							Math.floor(Math.random() * this.affirmations.length)
						];
					this.createParticles(centerX, centerY, 20, "#ffd700");
					this.createFloatingText(
						affirmation,
						centerX - 100,
						centerY - 100,
						"#ffd700"
					);

					setTimeout(() => {
						alert(
							`🎉 Congratulations! You found all words in ${this.formatTime(
								this.time
							)}! 🎉`
						);
					}, 1000);
				}

				// Timer methods
				resetTimer() {
					this.time = 0;
					this.timerStopped = false;
					this.timerPaused = false;
					document.getElementById("timer").textContent = "Time: 0:00";
				}

				startTimer() {
					this.timerInterval = setInterval(() => {
						if (!this.timerStopped && !this.timerPaused) {
							this.time++;
							document.getElementById(
								"timer"
							).textContent = `Time: ${this.formatTime(this.time)}`;

							// Pulse timer every 10 seconds
							if (this.time % 10 === 0) {
								this.pulseTimer();
							}
						}
					}, 1000);
				}

				stopTimer() {
					this.timerStopped = true;
					if (this.timerInterval) {
						clearInterval(this.timerInterval);
						this.timerInterval = null;
					}
				}

				toggleTimer() {
					this.timerPaused = !this.timerPaused;
					const timer = document.getElementById("timer");
					if (this.timerPaused) {
						timer.textContent = "⏸️ " + timer.textContent;
					} else {
						timer.textContent = timer.textContent.replace("⏸️ ", "");
					}
				}

				formatTime(seconds) {
					const mins = Math.floor(seconds / 60);
					const secs = seconds % 60;
					return `${mins}:${secs.toString().padStart(2, "0")}`;
				}

				// Line drawing methods
				updateLine(start, end) {
					const line = document.getElementById("selectionLine");
					const container = document.getElementById("wordSearchContainer");

					const startCell = start.element;
					const endCell = end.element;

					if (!startCell || !endCell) return;

					const containerRect = container.getBoundingClientRect();
					const startRect = startCell.getBoundingClientRect();
					const endRect = endCell.getBoundingClientRect();

					const startX =
						startRect.left + startRect.width / 2 - containerRect.left;
					const startY =
						startRect.top + startRect.height / 2 - containerRect.top;
					const endX = endRect.left + endRect.width / 2 - containerRect.left;
					const endY = endRect.top + endRect.height / 2 - containerRect.top;

					line.setAttribute("x1", startX);
					line.setAttribute("y1", startY);
					line.setAttribute("x2", endX);
					line.setAttribute("y2", endY);
				}

				clearLine() {
					const line = document.getElementById("selectionLine");
					line.setAttribute("x1", 0);
					line.setAttribute("y1", 0);
					line.setAttribute("x2", 0);
					line.setAttribute("y2", 0);
					line.setAttribute("stroke-opacity", "0");
				}

				drawPermanentLine(start, end) {
					const lineData = {
						startX: parseInt(start.element.dataset.x),
						startY: parseInt(start.element.dataset.y),
						endX: parseInt(end.element.dataset.x),
						endY: parseInt(end.element.dataset.y),
					};

					// Store line data for redrawing on resize
					this.drawnLines.push(lineData);

					this.drawPermanentLineFromData(lineData);
				}

				drawPermanentLineFromData(lineData) {
					const svg = document.getElementById("lineSVG");
					const newLine = document.createElementNS(
						"http://www.w3.org/2000/svg",
						"line"
					);

					const container = document.getElementById("wordSearchContainer");
					const containerRect = container.getBoundingClientRect();

					const startCell = document.querySelector(
						`[data-x="${lineData.startX}"][data-y="${lineData.startY}"]`
					);
					const endCell = document.querySelector(
						`[data-x="${lineData.endX}"][data-y="${lineData.endY}"]`
					);

					if (!startCell || !endCell) return;

					const startRect = startCell.getBoundingClientRect();
					const endRect = endCell.getBoundingClientRect();

					const startX =
						startRect.left + startRect.width / 2 - containerRect.left;
					const startY =
						startRect.top + startRect.height / 2 - containerRect.top;
					const endX = endRect.left + endRect.width / 2 - containerRect.left;
					const endY = endRect.top + endRect.height / 2 - containerRect.top;

					// Calculate dynamic line width
					const cellSize = startRect.width;
					const lineWidth = Math.max(3, Math.min(20, cellSize * 0.3));

					newLine.setAttribute("x1", startX);
					newLine.setAttribute("y1", startY);
					newLine.setAttribute("x2", endX);
					newLine.setAttribute("y2", endY);
					newLine.setAttribute("stroke", "#d500ff");
					newLine.setAttribute("stroke-width", lineWidth);
					newLine.setAttribute("stroke-opacity", "0.8");
					newLine.setAttribute("stroke-linecap", "round");

					svg.appendChild(newLine);
				}

				clearOldLines() {
					const svg = document.getElementById("lineSVG");
					while (svg.children.length > 1) {
						svg.removeChild(svg.lastChild);
					}
				}

				// Hint and cheat methods
				showHint() {
					// Close menu
					document.getElementById("settingsContainer").classList.remove("open");
					document.getElementById("settingsOverlay").classList.remove("open");

					const remainingWords = this.placedWords.filter(
						(pw) => !this.foundWords.has(pw.word)
					);
					if (remainingWords.length === 0) {
						return;
					}

					// Play hint sound
					this.playHintSound();

					const randomWord =
						remainingWords[Math.floor(Math.random() * remainingWords.length)];
					const firstPos = randomWord.positions[0];
					const cell = document.querySelector(
						`[data-x="${firstPos.x}"][data-y="${firstPos.y}"]`
					);

					if (cell) {
						cell.classList.add("hint");

						// Create sparkles around the hint
						const rect = cell.getBoundingClientRect();
						const x = rect.left + rect.width / 2;
						const y = rect.top + rect.height / 2;
						this.createSparkles(x, y, 3);

						setTimeout(() => {
							if (!this.foundWords.has(randomWord.word)) {
								cell.classList.remove("hint");
							}
						}, 3000);
					}
				}

				cheatNextWord() {
					const remainingWords = this.placedWords.filter(
						(pw) => !this.foundWords.has(pw.word)
					);
					if (remainingWords.length === 0) {
						alert("You've found all the words!");
						return;
					}

					const nextWord = remainingWords[0];
					this.foundWords.add(nextWord.word);

					// Mark cells as found and draw the line
					this.markWordAsFound(
						nextWord.word,
						nextWord.positions.map((pos) => pos)
					);

					// Create fake start/end for line drawing
					const startPos = nextWord.positions[0];
					const endPos = nextWord.positions[nextWord.positions.length - 1];
					const start = {
						element: document.querySelector(
							`[data-x="${startPos.x}"][data-y="${startPos.y}"]`
						),
					};
					const end = {
						element: document.querySelector(
							`[data-x="${endPos.x}"][data-y="${endPos.y}"]`
						),
					};

					if (start.element && end.element) {
						this.drawPermanentLine(start, end);
					}

					this.updateWordsList();
					this.updateStats();
					this.foundWordsCount++;

					if (this.foundWordsCount === this.placedWordsCount) {
						this.gameComplete();
					}
				}

				// Wins tracking
				updateWinsCount() {
					try {
						const winsCount = localStorage.getItem("wordSearchWins") || 0;
						document.getElementById("winsCount").textContent = winsCount;
					} catch (error) {
						console.warn("Failed to get wins count from localStorage:", error);
						try {
							document.getElementById("winsCount").textContent = "0";
						} catch (error) {
							console.warn("Failed to set wins count to 0:", error);
						}
					}
				}

				incrementWins() {
					try {
						let winsCount = parseInt(
							localStorage.getItem("wordSearchWins") || 0
						);
						winsCount++;
						localStorage.setItem("wordSearchWins", winsCount);
						this.updateWinsCount();
					} catch (error) {
						console.warn("Failed to save wins count to localStorage:", error);
					}
				}
			}

			// Global functions
			let game;

			function newGame() {
				if (game) {
					game.cleanup(); // Properly cleanup old game instance
				}
				game = new WordSearch();
			}

			function showHint() {
				if (game) {
					game.showHint();
				}
			}

			function cheatNextWord() {
				if (game) {
					game.cheatNextWord();
				}
			}

			function setDifficulty(level) {
				if (game) {
					game.setDifficulty(level);
					game.createWordSearch();
				}
			}

			function setCategory(category) {
				if (game) {
					game.setCategory(category);
					game.createWordSearch();
				}
			}

			function toggleTimer() {
				if (game) {
					game.toggleTimer();
				}
			}

			function clearWins() {
				if (confirm("Are you sure you want to clear the wins count?")) {
					try {
						localStorage.setItem("wordSearchWins", 0);
						if (game) {
							game.updateWinsCount();
						}
					} catch (error) {
						console.warn("Failed to clear wins count:", error);
					}
				}
			}

			// Initialize the game when the page loads
			window.addEventListener("load", () => {
				newGame();
			});
		</script>
	</body>
</html>
